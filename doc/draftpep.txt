
The goal of this project is to produce code of a quality that would
be suitable for inclusion in the Python Standard Library -- adheres
to PEP 8, well documented, unit tests, etc.

If the code also happens to be popular enough to be included in the
Python Standard Library that would be a great thing, because the
configparser is somewhat limited.

For these reasons (and because it's a useful format for storing this
sort of formal document), this document is in quasi-PEP form.  It's
not very good yet, but I hope to polish it as time goes on.


Abstract
========

This document proposes a new standard file format, suitable for configuration
files and other similar files that are read and written by humans as well
as by computers.


Motivation
==========

Storing configuration information (and other similarly structured data)
is a very common programming task.  Python already has a library module
designed specifically for this task (configparser).

But configparser is inadequate for complex configuration needs, and
programmers often turn to XML, JSON, YAML, or even Python pickles for
their configuration storage needs.  (As a recent example, PEP 391 allows
logging configuration via dictionaries instead of configparser, and
specifically mentions using JSON or YAML as a source of the dictionaries.)

The goal of RSON (Readable Serial Object Notation) is to provide a
hierarchical file format that can be read or written by both computers
and humans quite easily, and an implementing Python library that is
eventually of high enough quality to be included in the standard library.

Current popular configuration file implementations fall short of this
goal in different ways:

- configparser uses a single level of hierarchy
- XML and JSON are not really that human-friendly
- pickles or database-stored configurations are not human-friendly at all
- YAML is not really that computer-friendly (more anon)


Rationale
=========

Popular alternatives
-------------------------

Storing configuration information is one of those tasks that is so
mundane that an application-specific reader/writer can often be written
in less than an hour.

But it is preferable to use a format that the human user has a chance of
understanding, with an available well-tested parser that can give meaningful
error messages, and for those reason, a few formats are more-or-less widely
used:


configparser .ini syntax
''''''''''''''''''''''''''''

The original ini files are great for a couple of levels of
dictionary-based configuration information, but fall short on
anything more complicated.


JSON
''''''''''

JSON is great.  The definition of JSON is clear and concise, computers
generate and understand it easily, and humans can generate and understand
it with a bit of effort.

But just because humans *can* understand JSON doesn't mean that humans
should be *forced to* understand JSON.  From a human factors perspective,
JSON suffers from the same problem as LISP -- nested elements are specified
with identical tiny special symbols, and it is extremely easy for the human
reader to get confused about the nesting level when looking at the symbols.
Of course, this can be ameliorated with whitespace, but if the human is
keying off the whitespace to keep from getting confused, why not make the
computer key off the whitespace, as well?  This is part of the theory
behind Python syntax, which works exceedingly well in practice.


XML
''''''''''

XML is also great for some problem domains.

The use of XML ameliorates the readability problem considerably, which
is one of the reasons some configuration files are maintained in XML.  But
even XML must be properly formatted (indented), in order for humans to
easily make sense of it.  And then the only real advantage XML has over JSON
is that instead of a generic "}" or "]" character, the tag gives the human
a much better indication of which element is being closed.  All this comes
at a huge price in verbosity.  While the average human can probably read
the average XML file more easily than he can read the average JSON file,
*writing* those files is a completely different story.  The average human
can probably easily make small changes to a preexisting XML file, but not
large changes.


YAML
'''''''

YAML attempts to fix some of the problems with the other formats.
According to yaml.org, "YAML is a human friendly data serialization
standard for all programming languages."  And it is.  YAML allows
users to write extremely readable configuration files.

On the surface, YAML looks great.  Unfortunately, YAML appears to suffer
even worse than XML from the burning desire to be the single file format
for all things -- the "Jack of all trades; master of none" syndrome.

For example, YAML has back-references, allowing an object to be included
in the hierarchy in multiple locations.  This is a wonderful feature for
some problem domains, but a configuration file which requires the average
human to understand and use this feature is a non-starter.  Although
programs are not required to *use* the back-references in configuration
files, the very existence of this feature makes a YAML parser work harder.

YAML also has too many predefined scalars.  Arguably, even the predefined
"true", "false", and "none" values of JSON are overkill, but when more
scalars are added, there are too many edge cases where the user might
think he is entering a string, but it is really a special identifier.
This leads to ambiguities at the user <-> YAML interface, and also at
the YAML <-> parser and parser <-> application interfaces.  For example,
as of the time of this writing (28-Feb-2010), the YAML reference card [1]_
shows a couple of the scalar type definitions as::

    { Y, true, Yes, ON  }    : Boolean true
    { n, FALSE, No, off }    : Boolean false

For one thing, this is too many.  But a closer examination leaves
a few questions.  How does the case-sensitivity work?  "Yes" and "No"
are both capitalized.  "ON" is all upper-case, and "off" is all lower-case.
Et cetera.  A look at the actual specification [2]_ shows that "true" and
"false" can be upper-case, lower-case, or capitalized, but no variants of
"off" or "on" or "yes" or "no" actually exist in the spec!

Apparently, "yes" and "no" were in the 1.1 spec, but not in the 1.2 spec,
but the reference card has not yet been updated.  This would be excusable
in a recent grammar, but YAML has been in development for the greater part
of a decade.

YAML has a huge grammar, and a search of the literature indicates that
very few, if any, of the extant parsers fully comply.  These facts are
not unrelated.

Because YAML does allow for highly readable configuration files, it
is tempting to overlook its other flaws for the task.  But a fully
(or almost) compliant parser has to understand the whole YAML
specification, and this is apparently expensive.  Running the rst2pdf
testsuite, without sphinx or most of the other optional packages, in
"fast" mode (preloading all the modules, and then forking for every
test) generates 161 smallish PDF files, totaling around 2.5 MB.  On
one test system this process takes 22 seconds.  Disabling the _json C
scanner and reading the configuration files using the json pure Python
implementation adds about 0.3 seconds to the 22 seconds.  But using
pyyaml v. 3.09 instead of json adds 33 seconds to the 22 second process!
It might seem that this is an edge case, but it makes it unacceptable to
use YAML for this sort of testing, and taking 200 ms to read in 1000
lines of simple JSON will be unacceptable in many other application
domains as well.

Design objective and goals
---------------------------

The primary objective of RSON is

    *"To set fire to configuration files everywhere."*

Or failing that, to fit a niche well enough to become a standard tool
in the Python programmer's toolbox.

RSON is for use with simple configuration-type files, where simple .ini
configuration file syntax is not expressive enough, JSON is too hard
for humans to parse, and YAML is too hard for computers to parse.

To meet this objective, RSON has a few simple goals:

-   RSON files should be semantically rich enough for complex configuration
    tasks, but should not support features that are too difficult for
    humans to easily parse in context (such as back references).

    To this end, RSON semantics are modelled on JSON.

-   It should be possible for a human to generate and maintain an
    easily readable RSON file.  This implies minimal required markup.

-   It should be easy for a computer to generate and parse correct
    RSON files.


Non-objectives
----------------------

RSON is not designed to be all things to all people:

- RSON is not designed to be a database.  Multi-megabyte files should
  probably be stored in some other syntax, because RSON is designed for smallish
  files that can be parsed in one go.

- RSON is not designed to support arbitrary source encoding.  Valid RSON
  strings are encoded in UTF-8 (or its ASCII subset).  An application which
  requires support of additional encodings can deal with the BOM and
  massage the source data appropriately before passing it to the RSON
  parser, but a file which is not in UTF-8 will not be considered
  RSON-compliant.


Semantics
------------------

RSON semantics are based on JSON.  Like JSON, an RSON document represents
either a single scalar object, or a tree of objects, which
may contain only a few simple data types.

In general, this document will use the Python nomenclature of dict, list,
string, number, True, False, and None to represent the JSON nomenclature
of object, array, string, number, true, false, and null.

This document does not currently contemplate adding syntax to support additional
data types or structural organization, although it does contemplate hooks
in the parser which would allow, for example, for an application to use
the Decimal class instead of floats and or ints when numeric tokens are
encountered.

The YAML syntax for supporting back-references was considered and deemed
unsatisfactory. A human user who wants to put identical information in a
"ship to" and "bill to" address is much more likely to use cut and paste
than he is to understand and use backreferences, so the additional overhead
of supporting more complex document structures is unwarranted.

The concept of a "merge" in YAML, where two sub-trees of data can be
merged together (similar to a recursive Python dictionary update)
is quite useful, though, and will be copied.  This does not alter the
outcome that parsing a RSON file will result in a tree, but does give
more flexibility in the syntax that can be used to achieve a particular
output tree.

In RSON, a merge to a non-existent entity is not an error, and will
create that entity.  Also, in RSON, lists can be merged with preexisting
lists, and dicts with preexisting dicts, but merging to a preexisting
object of a different type will discard the previous object and replace
it with the new one.


Syntax
------


Summary
'''''''''''

- RSON syntax is a superset of JSON syntax.
- RSON syntax does *not* attempt to be compatible with YAML syntax.
- In some cases, RSON allows indentation to be used to make the syntax
  more readable.
- Strings do not need quotes unless they contain characters which would
  be ambiguous in the context.
- "/" may be used as a key separator to easily construct nested dictionaries
- Triple-quotes may be used to allow inclusion of almost arbitrary string data.
- By default, RSON numbers allow additional radices and embedded underscores
  for readability, but the numeric parser can easily be subclassed or replaced.
- Comments can be included, on lines by themselves, at any indentation level,
  using "#"


Discussion
''''''''''''

YAML is a good starting point for looking at syntax.  The ability
to support JSON as a subset is a great design choice, and one that
RSON will emulate:

    **All valid UTF-8 encoded JSON files are also valid RSON files.**

The ability to specify strings in most contexts without requiring quotes
is also a necessity, as is the Pythonish use of indentation to denote
hierarchy.  The ability to merge data into preexisting dictionaries is
also very useful, and will be copied.

But, for example, the use of dash characters for array elements belies
YAML's current claim that "YAML Ain't Markup Language." Dashes are a good
choice for list bullets in markup, but a poor choice for configuration
files.  Lists with dashes are eminently readable, but require extra
effort for humans to write.

Other prior art which has informed the syntax selection for RSON includes
Windows registry-style keys, where multiple keys are separated by forward
slashes.  This useful feature practically requires the YAML-inspired
merge capability.  For example::

    key1/key2/key3/key4a
        foo = bar
        parrot = dead
    key1/key2/key3/key4b
        answer = 42

could result in the Python structure::

    {'key1': {'key2': {'key3': {
          'key4a': {'foo': 'bar', 'parrot': 'dead'},
          'key4b': {'answer': 42}
    }}}}

Another required RSON syntax feature that YAML and a few other
formats provide, but that JSON lacks, is the ability to cut and paste
entire strings from other files and embed them inside the syntax with
minimal alteration -- something which can be done with Python
triple-quoted strings.

The JSON number syntax is insufficient for many real-world
applications.  The default RSON parser will take its cue from real-world
programming and hardware languages, and add both the ability to use
other radices than 10, and the ability to separate parts of a number
with underscores for readability.

However, the subparser which determines how to interpret numbers will
be a small part of the RSON parser, easily subclassed or replaced by
application-specific code (to enhance the syntax or use Decimal instead
of float, for example).  This subparser will receive tokens that are
not quoted, and do not have embedded whitespace or RSON syntax elements,
and will determine and return the correct object representation for the
token.

Finally, because of the human-readable nature of the files, the ability
to insert comments is a necessity.  However, because of the desire to
have a simplified syntax which does not require quotes for strings in
many contexts, comments may not be placed on the same line with anything
else, other than space-based indentation.


Specification
==================


Syntax Elements
---------------

All valid RSON strings are UTF-8 (or plain ASCII) encoded.
RSON uses a minimal set of special symbols and keywords:

========================= ======================================================================================
**{}**                    Dictionary delimiters
**[]**                    List delimiters
**"**                     String delimiter
**\\**                    String escape character
**,**                     Element separator inside {} amd [] delimiters
**:**                     Merging key/value separator, except when used inside {}, where it forces replacement.
**=**                     Replacement key/value separator
**/**                     Key/key separator for nested dictionaries
**#**                     Comment start character
'true', 'false', 'null'   JSON-compatible special identifiers, when not inside a string
indentation               Indentation is done with spaces only (no tabs).
line endings              Lines can end with \\n, \\r\\n, or \\r.
whitespace                Whitespace consists of spaces, \\n, \\r, \\t, \\f, and \\v.
========================= ======================================================================================


RSON objects
-------------

RSON objects are those Python objects which can be returned from calling rson.loads():

===========   ================================================================
list          Lists can contain any type of RSON object.
-----------   ----------------------------------------------------------------
dict          Dictionary values can contain any kind of RSON object.
              Dictionary keys can be scalars or tuples.
-----------   ----------------------------------------------------------------
tuple         Lists are automatically converted to tuples when used
              for dictionary keys.  Dicts are automatically converted to
              sorted tuples of key/value tuple pairs when used for dictionary
              keys.
-----------   ----------------------------------------------------------------
True          Returned when an unquoted "true" is found.
-----------   ----------------------------------------------------------------
False         Returned when an unquoted "false" is found.
-----------   ----------------------------------------------------------------
None          Returned when an unquoted "null" is found.
-----------   ----------------------------------------------------------------
number        Any unquoted string which is delimited by whitespace and/or
              RSON syntax elements, contains at least one digit, and can
              be interpreted as a number will be returned by the stock
              loads() as an int or a float, as appropriate.  Note, however,
              that it will be extremely easy to change this behavior by
              subclassing to use Decimal, and/or to make minor changes to
              acceptable number syntax.
-----------   ----------------------------------------------------------------
unicode       The default object type for RSON objects is unicode (Python 3.0
              str), although for Python 2.x, subclassing the rson parser can
              easily change this into str or some other representation.
===========   ================================================================


Syntax rules
-------------

RSON effectively has two syntax modes.  Any elements inside an enclosing
{} or [] pair use "JSON-compatible" syntax rules, and elements outside
{} or [] use "indented hierarchy" syntax rules.

JSON-compatible syntax
'''''''''''''''''''''''''''

The JSON-compatible mode is a superset of JSON -- string quoting
requirements are relaxed such that quotes only need to be used
when strings contain RSON syntax elements, triple-quoted strings
are allowed, and numeric integer formats include hexadecimal,
octal, and binary, and allow embedded underscores.  Also, comments
are allowed on lines by themselves.

In JSON-compatible mode, line formatting is irrelevant, except
that non-quoted or single-quoted strings cannot span lines.

Indented mode syntax
'''''''''''''''''''''''''''

The indented hierarchy mode is modelled on Python indentation, where
indentation is relevant for non-comment, non-blank lines outside of
{} and [] structures.

Differences between Python and RSON indenting rules:

- The indentation of the first non-comment, non-blank line in the file
  is used as the initial indentation.  It does not need to be at the
  leftmost column.

- When indenting to a new level, spaces are used, never tabs.

========================= ======================================================================================
Indented mode non-scalar syntax elements
================================================================================================================
**#**                     Comment start character.  Must not be preceded by anything except optional spaces
------------------------- --------------------------------------------------------------------------------------
**{**                     Starts a JSON mode dictionary; leaves indented mode until matching **}** encountered
------------------------- --------------------------------------------------------------------------------------
**[**                     Starts a JSON mode list; leaves indented mode until matching **]** encountered
------------------------- --------------------------------------------------------------------------------------
**"**                     Starts a string; leaves indented mode until string completed.
------------------------- --------------------------------------------------------------------------------------
**:**                     Merging key/value separator.  If the value is on the same line (after the colon),
                          then the syntax rules are relaxed for the value and most characters (after the
                          initial character) can be used for non-quoted strings.
------------------------- --------------------------------------------------------------------------------------
**=**                     Replacement key/value separator.  If the value is on the same line (after the colon),
                          then the syntax rules are relaxed for the value and most characters (after the
                          initial character) can be used for non-quoted strings.
------------------------- --------------------------------------------------------------------------------------
**/**                     Key/key separator for nested dictionaries.  Must appear between valid key values.
------------------------- --------------------------------------------------------------------------------------
indentation               Indenting normally acts as a key/value separator, but this can be overridden
                          with special object constructors.
========================= ======================================================================================


The normal semantics of indented mode are that:

- If there is only a single line at a given (local) indentation level,
  the resultant object will either be a scalar, or a dictionary with
  a single entry (if there is a colon, equal sign, or slash
  to create a key/value pair).

- If there are multiple lines at a given (local) indentation level,
  the resultant object will either be a list or a dictionary, depending
  on whether the indented lines have colons, equal signs, or slashes
  to create key/value pairs.
  
  It is a syntax error to mix key/value pair lines at the same local
  indentation level as non- key/value pair lines.

Example::

    key1/key2a
        key3a = Some random string
        key3b = 42
    key1/key2a
        key3c
            1
            2
            3
            4
    key1/key2b = [1, 2, 3, 4]

This produces::

    {'key1':
        {'key2a':
            {'key3a': 'Some random string',
             'key3b': 42,
             'key3c': [1, 2, 3, 4]},
         'key2b':  [1, 2, 3, 4]}}


Controlling indented object types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the preceding example, it is not immediately apparent how to add
mixed-content into an array.  For example, if we wanted to insert
a dictionary in the key3c array, we could use JSON-compatible syntax,
but we would prefer to remain in the indented syntax.  For this
reason, RSON allows special object constructors:

        **[]**
             An empty list can be a starting point that can have
             list elements added to it, one per indented line.
        **{}**
             An empty dictionary can be a starting point that can
             have dictionary elements added to it, one per indented line.
        **""**
             An empty string can be a starting point to create a multi-line
             string.
        **[""]**
             A list containing a single string can be a starting point to
             create a list of strings, one per indented line.

Enhanced example::

    key1/key2a
        key3a = Some random string
        key3b = 42
    key1/key2a
        key3c
            1
            2
            {}
                key4a = anything
                key4b = something else
            []
                a
                b
                c
            3
            4
    key1/key2b = [1, 2, 3, 4]
    key5 = ""
       This is a multi-line string.  It is
          dedented to the farthest left
          column that is indented from
          the line containing "".
    key6 = [""]
       This is an array of strings, one per line.
       Each string is dedented appropriately.


RSON strings
'''''''''''''''

There are several ways to specify strings in RSON.

- In many contexts, unquoted strings can be used.  This is
  usually the case when not using RSON special characters, and
  sometimes the case even when usin some RSON special characters
  (after **=** or **:**, on the same line, the first character of the
  unquoted string cannot be **{**, **[**, or **"**, but subsequent
  characters can be anything.  No un-escaping is performed.

- JSON-compliant strings can be used.  See the specification
  at json.org for more information.  Escaping allows any characters
  to be used in the strings.

- Triple-quoted strings (three double-quotes) can be used.
  Within these strings, the only time escape characters are used
  is that \\""" is used for a literal three quotes in a row.

- Multiline strings (**""** followed by indentation) or string lists
  (**[""]** followed by indentation) can be used.  In either case,
  no un-escaping is performed, and the strings are dedented such
  that the left-most line has no whitespace in the string, and the
  strings are right-stripped of whitespace.


Syntax BNF
-------------

TBD, if necessary, once consensus is reached on syntax.

Implementation
================

Implementation in progress at rson.googlecode.com
 
Help would certainly be appreciated on the implementation and testing,
after consensus is reached on the syntax.

References
==========

.. [1] YAML 1.1 Reference card
   (http://yaml.org/refcard.html)

.. [2] YAML 1.2 Specification
   (http://www.yaml.org/spec/1.2/spec.html)



Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
